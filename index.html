<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>Rust and C++</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/slint.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>

  <body>
    <div class="reveal">
      <div class="slides">
        <!-- # INTRO -->
        <section>
          <!-- ## TITLE -->
          <section style="text-align: right; margins: 100px; width: 100%">
            <h1 class="r-fit-text">Rust and C++</h1>
            <h3>Tobias Hunger</h3>
            <aside class="notes">
              <p>Organisational:</p>
              <ul>
                <li>Please tell me if I am too fast or too slow!</li>
                <li>Slides will be available, list of links on last slide!</li>
                <li>
                  Feel free to ask questions, we will probably not have too much
                  time at the end. I might not be able to answer all of them
                  here, but I am around afterwards and will also provide ways to
                  reach out online!
                </li>
              </ul>
              <p>
                There is a lot of interest in using languages safer than C++
                right now, but there is also a lot of C++ code out there that we
                can not just leave behind.
              </p>

              <p>
                About the time I handed is the paper for this presentation
                Chandler Carruth introduced a new programming language at
                CppNorth It is supposed to become safer than C++, but at the
                same time stay fully compatible with it -- so that existing C++
                code can be reused.
              </p>

              <p>
                Since then Herb Sutter introduced cppfront at CppCon, a
                transpiler that compiles a new language called "cpp2" into C++
                and then builds it with a standard C++ compiler. Again a new
                language fully compatible with C++.
              </p>

              <p>
                Rust was developed at Mozilla, also with the goal to integrate
                into their existing C++ code base. Indeed rust code is shipped
                shipped in combination with a lot of C++ code in the firefox
                browser today.
              </p>

              <p>
                Integrating Rust and C++ is possible. This presentation wants to
                show some options you have to combine Rust and C++ code.
              </p>
            </aside>
          </section>

          <!-- ## MOTIVATION -->
          <section>
            <h3>About me</h3>
            <ul>
              <li>Long time C++ Developer</li>
              <li class="fragment fade-in">Now: Rust Developer</li>
            </ul>
            <aside class="notes">
              <h3>C++ dev</h3>
              <p>
                25 or so years, most of the time around and on UI technologies
                and tooling.
              </p>
              <h3>Rust</h3>
              <p>&hellip;still working on tooling&hellip;</p>
            </aside>
          </section>

          <!-- ## Slint -->
          <section
            data-background-image="slint-logo-full.svg"
            data-background-size="480px"
            data-background-position="right 5% top 5%"
          >
            <h2>Slint</h2>

            <h4>Scalable. Lightweight. Intuitive. Native. Toolkit.</h4>

            <ul>
              <li class="fragment fade-in">Provides C++ API</li>
              <li class="fragment fade-in">
                Optionally uses existing C++ code
              </li>
            </ul>
            <aside class="notes">
              <p>
                <em>Scalable</em>: Microcontroller to graphics accelerated
                workstation
              </p>
              <p><em>Lightweight</em>: Uses few resources</p>
              <p><em>Intuitive</em>: Simple UI description language</p>
              <p>
                <em>Native</em>: 100% Rust -- incl. the UI description parts
              </p>

              <p>
                We want to provide a nice API for users of other languages as
                well. Supports JS and C++ in addition to Rust. We want Slint to
                feel native in all languages.
              </p>
              <p>
                We optionally use existing code from C++ toolkits for some
                platform integration tasks.
              </p>
            </aside>
          </section>

          <!-- ## TOPICS -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>Topics</h2>
            <ul>
              <li>Making Rust and C++ talk to each other</li>
              <li>Build Projects mixing Rust and C++</li>
            </ul>
            <aside class="notes">
              <h3>Talk</h3>
              <p>Make Rust call C++ code and the other way around.</p>
              <h3>Build</h3>
              <p>Build projects that consist of rust code and C++ code</p>
            </aside>
          </section>
        </section>

        <!-- # TALKING TO C++ AND RUST -->
        <section
          data-background-image="slint-logo.svg"
          data-background-size="120px"
          data-background-position="right 5% top 5%"
        >
          <!-- ## TALKING -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>Making Rust and C++ talk to each other</h2>
            <aside class="notes">
              <p>Challenges:</p>
              <ul>
                <li>Rust has no defined ABI</li>
                <li>&hellip; neither has C++ (compiler defined!)</li>
                <li>
                  Languages have different concepts like inheritance, lifetimes,
                  templates, &hellip;
                </li>
                <li>
                  Data types do not match up. Even if they contain the "same"
                  data, field names/sequence/types will be different!
                </li>
                <li>
                  Even if datatypes would match up: Different requirements on
                  the representation of contained data. E.g. utf-8 encoded
                  strings in rust vs. bytes in unknown encoding in C++)
                </li>
              </ul>
              <p>Least common denominator: C foreign function interface</p>
              <p>
                C FFI is the backbone all the options we discuss are built upon.
              </p>
            </aside>
          </section>

          <!-- ## AUTOMATIC -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>Automatic binding generation</h2>
            <ul>
              <li class="fragment fade-in">
                <bold><code>bindgen</code></bold
                >: C and simple C++ &#8594; Rust
              </li>
              <li class="fragment fade-in">
                <bold><code>cbindgen</code></bold
                >: Rust &#8594; C or C++11 headers
              </li>
            </ul>
            <aside class="notes">
              <p>
                Idea: Examine existing code and generate C FFI-based bindings
                from that!
              </p>
              <p>These tools typically are uni-directional!</p>

              <h3>bindgen</h3>

              <p>Parses header files and generates a rust code out of it.</p>

              <p>
                Will try to convert whatever it can, skipping constructs it can
                not handle.
              </p>

              <p>
                Problems incl. templates, inline functions, exceptions,
                automatically calling copy/move constructors, cross-language
                inheritance.
              </p>

              <p>
                Needs manual configuration to block types that don't work or
                mark them as "opaque"
              </p>

              <h3>cbindgen</h3>

              <p>
                Parses rust code and exposes types and functions marked as
                <code>repr("C")</code>.
              </p>

              <p>
                Typically works reliably as the programmer has already put in
                the hard work by marking up functions and types.
              </p>

              <p>
                These are just the most commonly used ones, more tools available.
              </p>
            </aside>
          </section>

          <!-- ## SEMI-AUTOMATIC -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>Semi-automatic binding generation</h2>
            <h3 class="fragment fade-in"><code>cxx</code> crate</h3>
            <aside class="notes">
              <p>
                Requires custom code/data to generate bindings for C++ and Rust
                from. A C FFI interface is "hidden" between the two bindings.
              </p>

              <h3>cxx</h3>

              <p>
                Most widely used crate in this area, other build on top or
                beside this one.
              </p>
            </aside>
          </section>

          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h3><code>cxx</code> crate</h3>
            <pre><code data-trim data-noescape data-line-numbers="1-2|3-6|8-12|14-21">
#[cxx::bridge]
mod ffi {
    struct Metadata {
        size: usize,
        tags: Vec&lt;String&gt;,
    }

    extern "Rust" {
        type MultiBuf;

        fn next_chunk(buf: &mut MultiBuf) -> &[u8];
    }

    unsafe extern "C++" {
        include!("demo/include/blobstore.h");

        type Client;

        fn new_client() -> UniquePtr&lt;Client&gt;;
        fn put(&self, parts: &mut MultiBuf) -> u64;
    }
}</code></pre>
            <aside class="notes">
              <p>Code taken straight from crates demo!</p>

              <p>
                Aim: Describe interface and generate <em>safe</em> and
                <em>fast</em> bindings from and to C++ code.
              </p>

              <p>
                <em>safe</em>: Safe in the rust sense: Rust compiler enforces
                its invariants. The C++ isn't safe in this sense: The rust
                compiler can not reason about the C++ code. The code generated
                by cxx is safe.
              </p>

              <p>
                <em>fast</em>: Zero copy, no transformations going between
                languages => custom types like <code>CxxString</code> in rust
                and <code>rust::String</code> in C++!
              </p>

              <p>Interface definition in rust. Macro for the win!</p>

              <p>
                Shared data structures go straight into the
                <code>ffi</code> module. cxx maps data types.
              </p>

              <p>
                structs and functions/methods exposed from Rust. Must be in
                parent scope!
              </p>

              <p>
                structs and functions/methods exposed from C++. Important! Add
                unsafe/lifetimes here, which will be ignored in C++ but leads to
                better bindings. cxx will assert that signatures match!
              </p>

              <p>How does this work?</p>

              <p>
                Code is generated from this definition that implements C FFI +
                nicer facade in front of that:
              </p>
              <ul>
                <li>Rust side: Macro-based, so during rust build</li>
                <li>
                  C++: As part of build.rs/via command line tool. Needs build
                  system integration!
                </li>
              </ul>
            </aside>
          </section>

          <!-- ## NO BINDING -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>No binding generation</h2>
            <ul>
              <li class="fragment fade-in"><code>cpp</code> crate</li>
            </ul>
            <aside class="notes">
              <p>
                Use C++ code directly! Of course you still need to do bindings
                for data types and such ;-)
              </p>

              <h3>cpp</h3>

              <p>
                Some macros that enable embedding of C++ code right into the
                middle of your rust code!
              </p>

              <p>
                Works by extracting the C++ bits, wrapping them into function
                definitions and calling them in the right places.
              </p>
              <p>What does that look like?</p>
            </aside>
          </section>

          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <pre><code data-trim data-noescape>fn notify(&self) {
  let obj = self.obj;









}</code></pre>
            <aside class="notes">
              <p>Just write normal rust code&hellip;</p>
            </aside>
          </section>

          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <pre><code data-trim data-noescape data-line-numbers=3-9>fn notify(&self) {
  let obj = self.obj;
  cpp!(unsafe [obj as "Object*"] {
    auto data = queryInterface(obj)->data();


            
    updateA18y(&Event(obj));
  });
}</code></pre>
            <aside class="notes">
              <p>
                &hellip; then use the <code>cpp</code> macro and continue to
                write C++.
              </p>
            </aside>
          </section>

          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <pre><code data-trim data-noescape data-line-numbers=5-7>fn notify(&self) {
  let obj = self.obj;
  cpp!(unsafe [obj as "Object*"] {
    auto data = queryInterface(obj)->data();
    rust!(rearm [data: Pin<&A18yItemData> as "void*"] {
      data.arm_state_tracker();
    });
    updateA18y(&Event(obj));
  });
}</code></pre>
            <aside class="notes">
              <p>
                You can even use a <code>rust!</code> pseudo-macro to switch
                back into rust.
              </p>

              <p>
                You might still need some data types you can pass between
                languages. cpp has some more macros to help defining those. You
                need that when both sides need to access the same data.
                Otherwise you can use void*/*c_void to pass objects through the
                "other" language.
              </p>

              <p>
                Inlining of <code>cpp!(...)</code> macro code: Tricky to get
                right, but possible at the LLVM level with link time
                optimization.
              </p>
            </aside>
          </section>

          <!-- ## SUMMARY -->
          <section data-auto-animate data-auto-animate-restart>
            <h2>Summary</h2>
            <ul>
              <li class="fragment fade-in">
                A whole range of options for Rust to talk to C++ code
              </li>
              <ul>
                <li class="fragment fade-in">
                  &hellip; none is fully automatic!
                </li>
              </ul>
              <li class="fragment fade-in">
                No C++ compatibility built into Rust
              </li>
              <ul>
                <li class="fragment fade-in">External code generator</li>
                <li class="fragment fade-in">Macros!</li>
              </ul>
            </ul>
            <aside class="notes">
              <p>
                Rust can develop independent of strength and weaknesses of C++
                type system. That's a good thing for a language ;-)
              </p>
              <p>
                Integration of C++ into Rust via standard mechanisms of the
                language.
              </p>
              <p>Macros in rust are so extremely powerful!</p>
              <p>Integration of rust into C++ limited, but possible</p>
            </aside>
          </section>
        </section>

        <!-- # BUILD TOOLING -->
        <section
          data-background-image="slint-logo.svg"
          data-background-size="120px"
          data-background-position="right 5% top 5%"
        >
          <!-- ## SETUP -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h1>Building mixed projects</h1>

            <aside class="notes">
              <p>
                Now that we know how to make C++ and Rust talk to each other,
                how can we build the combined codebase? It depends on which
                language implements the final binary.
              </p>

              <p>
                You will typically have one build system for your C++ project
                and another build system for your rust project. The task is to
                integrate one build system into the other: It's often not
                practical to redo the build system of a project!
              </p>
              <p>
                Replacing the Rust build system is tricky: Cargo is the official
                interface to build rust code. The rust compiler's command line
                interface is an internal interface according to the rust
                community.
              </p>
            </aside>
          </section>

          <!-- ## CARGO -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>Cargo</h2>

            <p>A little C++ in a Rust project.</p>

            <h3 class="fragment fade-in"><code>build.rs</code></h3>

            <ul>
              <li class="fragment fade-in"><code>cc</code> crate</li>
              <li class="fragment fade-in"><code>cmake</code> crate</li>
            </ul>

            <aside class="notes">
              <p>
                First step: Check crates.io! Maybe somebody has already done
                bindings?
              </p>

              <h3>build.rs</h3>

              <p>
                If you want to build a rust binary linking to C/C++ code, then
                you need to integrate generating that into cargo
              </p>

              <p>
                You extend Cargo build adding a build.rs file. That's built
                during the build and then executed to extend Cargos
                functionality!
              </p>

              <h3>cc and cmake</h3>

              <p>
                To make C/C++ integration easier you can use crates as
                dev-dependency (build time dependency!).
              </p>

              <p>
                E.g. cc to drive the C/C++ compiler directly or cmake to build a
                cmake project.
              </p>

              <p>
                Of course you can also go the other direction: Let cmake drive
                the build and delegate to cargo to build some rust code into a
                library.
              </p>
            </aside>
          </section>

          <!-- ## CMake -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
          >
            <h2>CMake</h2>

            <p>A little Rust in a C++ project.</p>

            <h3 class="fragment fade-in">Corrosion</h3>
            <pre class="fragment fade-in"><code data-trim data-noescape>
cmake_minimum_required(VERSION 3.15)
project(MyCoolProject LANGUAGES CXX)

find_package(Corrosion REQUIRED)

corrosion_import_crate(MANIFEST_PATH rust-lib/Cargo.toml)

add_executable(cpp-exe main.cpp)
target_link_libraries(cpp-exe PUBLIC rust-lib)</code></pre>
            <aside class="notes">
              <p>
                The corrosion project on Github tries to make it simple to have
                a cargo project as a subproject in CMake.
              </p>

              <p>
                It will parse your cargo build system and expose all build
                targets to cmake.
              </p>
            </aside>
          </section>
        </section>

        <!-- # EPILOG -->
        <section
          data-background-image="slint-logo.svg"
          data-background-size="120px"
          data-background-position="right 5% top 5%"
        >
          <!-- ## THANK YOU -->
          <section>
            <h2>Thank you!</h2>
            <p>Mail: tobias.hunger@slint-ui.com</p>
            <p>Twitter: @t_hunger</p>
          </section>

          <!-- ## LINKS I -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
            data-visibility="uncounted"
          >
            <h2>Links I</h2>
            <ul>
              <li>
                <a href="https://youtu.be/omrY53kbVoA">Carbon announcement</a>
              </li>
              <li>
                <a href="https://youtu.be/ELeZAKCN4tY">Cppfront announcement</a>
              </li>
              <li><a href="https://slint-ui.com/">Slint website</a></li>
              <li>
                <a href="https://crates.io/crates/bindgen">bindgen crate</a>
              </li>
              <li>
                <a href="https://crates.io/crates/cbindgen">cbindgen crate</a>
              </li>
              <li>
                <a
                  href="https://endl.ch/content/cxx2rust-pains-wrapping-c-rust-example-qt5"
                  >Challenges converting C++ to Rust</a
                >
              </li>
              <li>
                <a href="https://github.com/KDE/rust-qt-binding-generator"
                  >KDE rust binding generator</a
                >
              </li>
            </ul>
          </section>

          <!-- ## LINKS II -->
          <section
            data-background-image="slint-logo.svg"
            data-background-size="120px"
            data-background-position="right 5% top 5%"
            data-visibility="uncounted"
          >
            <h2>Links II</h2>
            <ul>
              <li>
                <a href="https://github.com/KDE/rust-qt-binding-generator"
                  >KDE rust binding generator</a
                >
              </li>
              <li><a href="https://crates.io/crates/cxx">cxx crate</a></li>
              <li><a href="https://crates.io/crates/cpp">cpp crate</a></li>
              <li>
                <a href="https://youtu.be/NpyRZsbdJXE"
                  >Olivier Goffart talking about the cpp crate</a
                >
              </li>
              <li><a href="https://crates.io/crates/cc">cc crate</a></li>
              <li><a href="https://crates.io/crates/cmake">cmake crate</a></li>
              <li>
                <a href="https://github.com/corrosion-rs/corrosion"
                  >corrosion-rs</a
                >
              </li>
            </ul>
          </section>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        controls: false,
        hash: true,

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],

        parallaxBackgroundImage: "background.jpg",
        parallaxBackgroundSize: "5376px 3040px",
      });
      // Reveal.configure({
      //   showNotes: "separate-page",
      //   pdfSeparateFragments: false,
      // });
    </script>
  </body>
</html>
